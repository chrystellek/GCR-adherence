---
title: "Notebook"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

Chrystelle Kiang

```{r}
#| warning: false
#| message: false
#| label: setup

library(here) 
library(tidyverse)
library(AdhereR)
library(patchwork)
library(gtsummary)

# import study dataset (created in data creation.R file) 
pharmstudydata <- readRDS("studypopdata.rds")
```

The study population dataset has everyone eligible based on year of diagnosis and stage AND pharmacy claims for patients whose ID matches for AI and Tamoxifen. There are extra people who do not have pharm data, those #s will be reported in results.qmd.

```{r}
#| label: in-results
# some of this code is more elegant in results file 
elig_pop <- pharmstudydata %>%
  distinct(StudyID, .keep_all = TRUE) 

# subset pts who have rx and those who have rx after diagnosis
rx_before_dx <- pharmstudydata %>%
  filter(dispense_dt <= dt_diagnosis) %>%
    distinct(StudyID, .keep_all = TRUE)

# number with prescriptions outside of study period
rx_before_study <- pharmstudydata %>%
  anti_join(rx_before_dx, by = "StudyID") %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
   summarise(last_dispense = max(dispense_dt)) %>%
  select(StudyID, last_dispense) %>%
  filter(!is.na(last_dispense),
         last_dispense < as.Date("2017-09-01", format = "%Y-%m-%d")) 

pop_no_rx <- pharmstudydata %>% 
  filter(is.na(dispense_dt)) %>%
      distinct(StudyID, .keep_all = TRUE)

study_pop <- pharmstudydata %>% 
  anti_join(rx_before_dx, by = "StudyID") %>%
  filter(!is.na(dispense_dt),
         dispense_dt >= as.Date("2017-09-01", format = "%Y-%m-%d")) %>%
  mutate(daily_dose = 1,
  # putting urban/rural var here in case we change definitions
    urb_rural = case_when(
    RURALURBAN_CONTINUUM_2013 %in% c(1:7) ~ "Urban",
    RURALURBAN_CONTINUUM_2013 %in% c(8,9) ~ "Rural")
  )
# changing this to dispense date 3 months before Jan 01 2018 for calculating MPR for month of Jan .

study_ids <- study_pop %>% 
  group_by(StudyID) %>%
  slice_head()
```

Convo with Kevin (3/7)

1.  Tumor record number (in data file) and changed to first filter by ER+ then min tumor number based on KW email response: SeqNum will be added and then I will update and filter by SeqNum, below. Selected for min SeqNum.

```{r}
#| eval: false
#| echo: true
#| label: seq-vs-tumor-number

# Reading datasets in. These are R version of csv file; don't want to edit.
GCRpop <- readRDS("./data/cancerstudypop.rds")
# this dataset has not been filtered by SEQNo but the studypop is
table(GCRpop$SEQNo, GCRpop$CTCTUMOR_RECORD_NUMBER)

GCRpop_min <- GCRpop %>%
  filter(SEQNo == min(SEQNo)) 

GCRpop2 <- GCRpop %>%
  filter(SEQNo == min(SEQNo)) %>%
  group_by(StudyID, SEQNo) %>%
  summarise(n_tumor = n_distinct(CTCTUMOR_RECORD_NUMBER))

```

3.  AI or tamoxifen before diagnosis date: the handful we looked at are second breast cancers. May filter/report Seq Num
4.  Small numbers: supress cells \<5 and rates for \<15
5.  Urban/rural variables: will be added and uploaded. Census and county level.
6.  Race and ethnicity: NH-White, NH-Black, Hisp/Lat. can see what other races Hisp/Lat overlap.

Below is code to test code that I'd like to put in results eventually.

```{r}
#| eval: false
#| echo: true

pharmstudydata <- pharmstudydata %>%
  mutate(final_study = ifelse(StudyID %in% study_pop$StudyID, 1, 0))

pop_info <- list(total_elig = n_distinct(elig_pop$StudyID),
                 no_rx = n_distinct(pop_no_rx$StudyID),
                 rx_predx = n_distinct(rx_before_dx$StudyID),
                 rx_prestudy = n_distinct(rx_before_study$StudyID),
                 total_study = n_distinct(study_pop$StudyID),
                 no_rx_percent = n_distinct(pop_no_rx$StudyID)/n_distinct(elig_pop$StudyID))

# flow chart
# TODO pass through variables vs. having to know numbers?
library(DiagrammeR)
grViz("digraph flow_diagram{
  graph [layout = dot, rankdir = TB]
  node [shape = box]
  
  eligGA [label = 'Eligible\n']
  no_rx [label = 'Do not have pharmacy data']
  study_pop [label = 'Study population']
  blank[label = '', width = 0.01, height = 0.01]
  
  {rank = same; blank no_rx}
  
  eligGA -> blank[dir = none]
  blank -> no_rx[ minlen = 3 ]
  blank -> study_pop
}")

```

Notes from data cleaning:

-   **Drug groups:** There were some people with both drug groups (AI and TAM). There are valid reasons that people would switch. 1) AI to TAM for pre-meno who then start menopause. 2) TAM to AI if postmeno have bad side effects (Convo with Tim 2/6) --\> included both.

    -   Also decided to look at all adjuvant endocrine therapy as one category, at least for now, as opposed to AI and TAM separately (could do that later).

-   **Prescription timing:** Some had prescription before diagnosis date. People can be prescribed TAM to shrink tumor before surgery (neoadjuvant) -\> excluded them entirely.

    -   Open questions: what is the source for date of diagnosis? (E.g., is date of diagnosis overridden at surgery vs. biopsy to explain prescription *before* dx)

-   **Tumor record number:** Q about tumor record number vs. sequence number for repeated tumors

    -   Tim thinks it's odd that 0 bilateral- still maybe related to tumor record number
    -   Update from KW: should be using SeqNum; tumor number is for each specific one hence why no bilateral. Will get SeqNum soon.

**Continuous Medication Availability (CMA)**: AdhereR package, largely based on Vollmer et al.

-   CMA1 is the total days supply, excluding last dispense event, in observation window/duration between first to last dispense event.

-   CMA1 is total days supply, excluding last dispense event, in observation window/duration between first to last event.

-   CMA2 is similar to CMA1 but *includes* last dispense event and time is based on the observation window (OW) specified. Not sure how the OW works when CMA2 used with sliding window. Package authors say that CMA2 includes duration of last event in numerator, and duration between start of last event to end of OW in denominator, which accounts for medication event happening before/after previous supply is finished.

-   CMA3 is CMA1 capped at 1.0

-   CMA4 is CMA2 capped at 1.0

-   CMA7 is \# days theoretical use/observation window period, where gap days between dispenses are not included in time interval; so this allows for carryover and excludes the left over supply

-   CMA8 is \# days theoretical use/observation window *with lagged start*, where gap days are not included in time interval, and the lag is the days of carry over supply

-   CMA9 is (# observation window days weighted by ratio of days supply)/observation window. This means carry over and extra supply is evenly spread until next event. Using this with sliding window presents an issue because it assigns a CMA to periods when the patient should be NA/too long after their episode has ended. It is good at estimating a CMA during gaps though; it's not perfect but ultimately less than 80% which is what really matters.

Feb 19: After reading more into Vollmer et al. (2012), I am not convinced that MPR is what we want to plot. MPR seems to be better suited for longer intervals (e.g., if wanted 6-months or whole study period) rather than what we're trying to consider. Proportion of days covered may actually be of interest. Vollmer suggests MDC is more indicator of medication dispense/whether refills obtained, which is what we're interested in as well though. **Will need to** **discuss/defend choice.**

Summary of notes from before: Had a lot of back and forth about which CMAs to use and trouble with the OW duration varying between patients. With CMA 1-4, got a lot of 1 or NA, then CMA 5-9, got 0's after last dispense until OW end, which made it seem like artificial non-adherence. The CMAs 5-9 would correctly classify as NA before the first dispenses.

-   unresolved thought from before: may need to quantify the number missing and whether it's because they stopped treatment early vs. should have stopped. But that is a question of persistence, not adherence.

My current solution is to run Sliding Window CMA function for each patient to allow for variation in OW. Set the follow up (FU) start before the study period start of Jan 1, 2018 to allow for calculation of adherence for the month of January 2018 if they were completing a fill.

### Interrupted Time Series

I've seen two versions of interrupted time series formulas:

-   Option 1: Y \~ $\beta_{0}$time + $\beta_{1}$COVID + $\beta_{2}$time \* COVID

-   Option 2: Y \~ $\beta_{0}$time + $\beta_{1}$COVID + $\beta_{2}$time since COVID start

where:

-   $\beta_{1}$ = trend before COVID

-   $\beta_{2}$ = level of change right after start of COVID

-   $\beta_{3}$ = trend after COVID

```{r}
#| echo: false
#| eval: false
#| label: testing-function

# creating subset to test function
handful_IDs <- sample(nrow(study_ids), 400, replace = FALSE)
handful <- study_pop %>%
  filter(StudyID %in% handful_IDs)
  
ID_dispense <- handful %>%
  group_by(StudyID) %>%
    arrange(dispense_dt) %>%
     summarise(first_dispense = min(dispense_dt),
          last_dispense = max(dispense_dt),
          days_supply = last(days_supply)) %>%
    mutate(end_supply = last_dispense + days_supply + days(30)) %>%
  select(StudyID, first_dispense, last_dispense, end_supply)

# 2. add columns back
study_run <- handful %>%
  inner_join(ID_dispense, by = "StudyID") %>%
  mutate(horm_mo = case_when(is.na(CTCRX_SUMM_DATE_HORMONE_MM) ~ 1,
                              TRUE ~ CTCRX_SUMM_DATE_HORMONE_MM),
         horm_dd = case_when(is.na(CTCRX_SUMM_DATE_HORMONE_DD) ~ 1,
                            TRUE ~ CTCRX_SUMM_DATE_HORMONE_DD),
         horm_dt = case_when(!is.na(CTCDATE_OF_DIAGNOSIS_YYYY) ~ as.Date(
           paste(CTCDATE_OF_DIAGNOSIS_YYYY,
                 sprintf("%02d", as.numeric(horm_mo)),
                 sprintf("%02d", as.numeric(horm_dd)),
                 sep = "-"), format = "%Y-%m-%d")),
         horm_end_dt = horm_dt + years(5),
         death_dt = case_when(PATIENTVITAL_STATUS == 0 ~ as.Date(paste(PATIENTDATE_OF_LAST_CONTACT_YYYY, PATIENTDATE_OF_LAST_CONTACT_MM, PATIENTDATE_OF_LAST_CONTACT_DD,
                 sep = "-"), format = "%Y-%m-%d")),
         OW_end = case_when(PATIENTVITAL_STATUS == 0 ~ max(as.Date("2018-01-01",format = "%Y-%m-%d"), death_dt),
                            PATIENTVITAL_STATUS == 1 ~ max(end_supply, horm_end_dt)),
         OW_duration = max(as.integer(ceiling((difftime(OW_end, "2018-01-01", units = "weeks"))/4) * 4),0))

# code for function moved to chunk below

result_list2 <- c()
for (i in unique(study_run$StudyID)){
  study_data <- study_run[study_run$StudyID == i, ]
  result <- run_CMA(study_data, "CMA5")
  result_list2[[i]] <- result
}

all_results2 <- bind_rows(result_list2)

ugh <- study_run %>%
  group_by(StudyID) %>%
  map_dfr(~ run_CMA7(.))

ugh <- get_cma_results(all_results, COVID_start)
ugh$reg_plot
summary(ugh$data_summary)
```

Looks like this works.

```{r}
#| warning: false
#| label: create-functions

# function to run CMA
run_CMA <- function(data, CMA_to_use){
  # creating these so can change inside of function to be able to loop thru
  FU_start <- as.Date("2017-10-09", format = "%Y-%m-%d") 
  FU_end <- as.Date("2022-01-01", format = "%Y-%m-%d")
  FU_duration <- as.integer(difftime(FU_end, FU_start, units = "weeks"))
  Jan1 <- as.Date("2018-01-01", format = "%Y-%m-%d")
  
  OW_duration <- min(208, first(data$OW_duration), na.rm = TRUE)
  
    cma <- CMA_sliding_window(CMA.to.apply = CMA_to_use,
                     data = data,
                     ID.colname = "StudyID",
                     event.date.colname = "dispense_dt",
                     event.duration.colname = "days_supply",
                     event.daily.dose.colname ="daily_dose",
                     medication.class.colname = "AETdrug",
                     carry.only.for.same.medication = FALSE,
                     consider.dosage.change = FALSE,
                     followup.window.start = FU_start,
                     followup.window.duration = FU_duration,
                     followup.window.duration.unit = "weeks",
                     observation.window.start = Jan1,
                     observation.window.duration = OW_duration,
                     observation.window.duration.unit = "weeks",
                     sliding.window.start = 0, 
                     sliding.window.start.unit = "weeks",
                     sliding.window.duration = 4,
                     sliding.window.duration.unit = "weeks",
                     # if window and step are same, there is no overlap
                     sliding.window.step.duration = 4,
                     sliding.window.step.unit = "weeks",
                     date.format = "%Y/%m/%d",
                     parallel.backend = "none",
                     parallel.threads = 1) 
  result <- as_tibble(cma$CMA)
  return(result)
}
# function that outputs regression table and basic ggplot
# input dataset is the output of CMA results saved as tibble
get_cma_results <- function(dataset, COVID_start){
  reg_output <- c()
  reg_summary <- c()
  reg_plot <- c()
  results_list <- c()
  
  dataset <- dataset %>%
      mutate(adherent = case_when(
      CMA >= 0.80 ~ 1,
      CMA < 0.80 ~ 0)) %>%
    group_by(window.ID, window.start) %>%
    reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            # TODO run CMAs again, updated to mean() because of NAs
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA) %>%
    mutate(post_COVID = if_else(window.start >= COVID_start, 1, 0)) %>%
    distinct()
  
  its <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = dataset)
  reg_summary <- summary(its)
  
  dataset2 <- dataset %>% na.omit(prop_adherent) %>%
    mutate(fit = predict(its))

  reg_plot <- ggplot(dataset2, aes(x = window.start, y = prop_adherent)) +
    geom_point() +
    geom_line(aes(y = fit), colour = "blue", linewidth = 1) +
    geom_vline(xintercept = COVID_start, colour = "red") 
  
  results_list <- list(data_summary = dataset,
                       reg_output = its,
                   reg_summary = reg_summary,
                   reg_plot = reg_plot)
  return(results_list)
}
```

```{r}
#| echo: true
#| eval: false
#| label: simple-OW

# 1. get each person's overall persistent episode and IDs
IDlist <- study_pop %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
   summarise(first_dispense = min(dispense_dt),
          last_dispense = max(dispense_dt),
          days_supply = last(days_supply)) %>%
  mutate(OW_end = last_dispense + days_supply + 30,
         OW_duration = max(0,as.integer(ceiling((difftime(OW_end, "2018-01-01", units = "weeks"))/4) * 4))) %>%
  select(StudyID, first_dispense, last_dispense, OW_end, OW_duration)
# 2. add columns back
study_run2 <- study_pop %>%
  inner_join(IDlist, by = "StudyID")
# 3. loop through
results_shorterOW <- bind_rows(study_run2 %>%
                           group_by(StudyID) %>%                          
                           run_CMA7(.))

```

Updating the observation windows to be the max between 5 years post-hormone therapy OR 30 days after last supply, and ending if dead

```{r}
#| echo: true
#| warning: false
#| label: longer-OW

# 1. getting last dispense date for each ID
ID_dispense <- study_pop %>%
  group_by(StudyID) %>%
    arrange(dispense_dt) %>%
     summarise(first_dispense = min(dispense_dt),
          last_dispense = max(dispense_dt),
          days_supply = last(days_supply)) %>%
    mutate(end_supply = last_dispense + days_supply + days(30)) %>%
  select(StudyID, first_dispense, last_dispense, end_supply)

# 2. add columns back
study_run_OW <- study_pop %>%
  inner_join(ID_dispense, by = "StudyID") %>%
  mutate(horm_mo = case_when(is.na(CTCRX_SUMM_DATE_HORMONE_MM) ~ 1,
                              TRUE ~ CTCRX_SUMM_DATE_HORMONE_MM),
         horm_dd = case_when(is.na(CTCRX_SUMM_DATE_HORMONE_DD) ~ 1,
                            TRUE ~ CTCRX_SUMM_DATE_HORMONE_DD),
         horm_dt = case_when(!is.na(CTCDATE_OF_DIAGNOSIS_YYYY) ~ as.Date(
           paste(CTCDATE_OF_DIAGNOSIS_YYYY,
                 sprintf("%02d", as.numeric(horm_mo)),
                 sprintf("%02d", as.numeric(horm_dd)),
                 sep = "-"), format = "%Y-%m-%d")),
         horm_end_dt = horm_dt + years(5),
         death_dt = case_when(PATIENTVITAL_STATUS == 0 ~ as.Date(paste(PATIENTDATE_OF_LAST_CONTACT_YYYY, PATIENTDATE_OF_LAST_CONTACT_MM, PATIENTDATE_OF_LAST_CONTACT_DD,
                 sep = "-"), format = "%Y-%m-%d")),
         OW_end = case_when(PATIENTVITAL_STATUS == 0 ~ max(as.Date("2018-01-01",format = "%Y-%m-%d"), death_dt),
                            PATIENTVITAL_STATUS == 1 ~ max(end_supply, horm_end_dt)),
         OW_duration = as.integer(ceiling((difftime(OW_end, "2018-01-01", units = "weeks"))/4) * 4))

# 3. loop through
# TODO could create this as a function.. but prob not necessary
result_list <- c()
for (i in unique(study_run_OW$StudyID)){
  study_data <- study_run_OW[study_run_OW$StudyID == i, ]
  result <- run_CMA(study_data, "CMA6")
  result_list[[i]] <- result
}

cma6_results <- bind_rows(result_list)
saveRDS(cma6_results, "./data/cma6.rds")

COVID_start <- as.Date("2020-03-11", format = "%Y-%m-%d")
dataset6 <- cma6_results %>%
      mutate(adherent = case_when(
      CMA >= 0.80 ~ 1,
      CMA < 0.80 ~ 0)) %>%
    group_by(window.ID, window.start) %>%
    reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            # TODO run CMAs again, updated to mean() because of NAs
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count)) %>%
    mutate(post_COVID = if_else(window.start >= COVID_start, 1, 0)) %>%
    distinct()

summary(dataset6)

### CMA5
result_list <- c()
for (i in unique(study_run_OW$StudyID)){
  study_data <- study_run_OW[study_run_OW$StudyID == i, ]
  result <- run_CMA(study_data, "CMA5")
  result_list[[i]] <- result
}

cma5_results <- bind_rows(result_list)
saveRDS(cma5_results, file = "./data/cma5.rds")

dataset5 <- cma5_results %>%
      mutate(adherent = case_when(
      CMA >= 0.80 ~ 1,
      CMA < 0.80 ~ 0)) %>%
    group_by(window.ID, window.start) %>%
    reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            # TODO run CMAs again, updated to mean() because of NAs
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count)) %>%
    mutate(post_COVID = if_else(window.start >= COVID_start, 1, 0)) %>%
    distinct()

summary(dataset5)

### CMA7
result_list <- c()
for (i in unique(study_run_OW$StudyID)){
  study_data <- study_run_OW[study_run_OW$StudyID == i, ]
  result <- run_CMA(study_data, "CMA7")
  result_list[[i]] <- result
}

cma7_results <- bind_rows(result_list)
saveRDS(cma7_results, file = "./data/cma7.rds")

dataset7 <- cma7_results %>%
      mutate(adherent = case_when(
      CMA >= 0.80 ~ 1,
      CMA < 0.80 ~ 0)) %>%
    group_by(window.ID, window.start) %>%
    reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            # TODO run CMAs again, updated to mean() because of NAs
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count)) %>%
    mutate(post_COVID = if_else(window.start >= COVID_start, 1, 0)) %>%
    distinct()

summary(dataset7)

its7 <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = dataset7)
  summary(its7)
  
dataset7$fit <- predict(its7)

ggplot(dataset7, aes(x = window.start, y = prop_adherent)) +
    geom_point() + geom_line() +
    geom_line(aes(y = fit), colour = "blue", linewidth = 1) +
    geom_vline(xintercept = COVID_start, colour = "red") +  labs(title = "4-week PDC (CMA7)", x = "Year", y = "Proportion Adherent (80%)") +
  theme_bw() + scale_y_continuous(limits = c(0.1,1)) 

# TODO repeat CMA7 with shorter OW.

cma5_original <- readRDS("./data/pdc-cma5.rds")
cma5_results <- get_cma_results(cma5_original, COVID_start)
cma5_data <- cma5_results$data_summary
cma5_plot <- cma5_results$reg_plot + 
  geom_line() +
  labs(title = "4-week PDC", x = "Year", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0.5,1)) +
  theme_classic()

cma5_plot / plot2

ggplot(data = cma5_data, aes())
write_csv(new_OW_data, "./data/new-cma-March-19.csv")
write_csv(cma5_data, "./data/cma5-March-19.csv")

summary(new_OW_data$prop_adherent)


```

Note that some patients summary hormone suggest that it was not administered, yet patients still have prescriptions. Also do have some who were dead before FU start; may need to update study population. The plots look VERY similar; this didn't make a big difference though after all.

#### Start date

Okay now doing the ITS, comparing March and April as COVID dates. April allows for lag between start of COVID and when it would actually impact people whose prescriptions had not yet run out when the pandemic started and before Georgia actually imposed restrictions.

```{r}
#| echo: true
#| warning: false
#| label: compare-april

FU_start <- as.Date("2017-10-09", format = "%Y-%m-%d") 
COVID_start <- as.Date("2020-03-11", format = "%Y-%m-%d")
april_start <- as.Date("2020-04-01", format = "%Y-%m-%d")

# TODO do this again with updated code
# comparing March and April 
##########
cma5_april <- get_cma_results(cma5_original, april_start)
cma5_april_plot <- cma5_april$reg_plot + 
  labs(title = "4-week PDC (CMA5) with April start", x = "Year", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0.5,1)) 
cma5_april_plot
cma5_april_data <- cma5_april$data_summary
april_its <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = cma5_april_data)
summary(april_its)

april_test <- cma5_april_data %>% 
  na.omit(prop_adherent) %>%
    mutate(fit = predict(april_its))
  
COVID_start <- as.Date("2020-03-11", format = "%Y-%m-%d")
cma5_original <- readRDS("./data/pdc-cma5.rds")

cma5_march <- get_cma_results(cma5_original, COVID_start)
cma5_plot <- cma5_march$reg_plot + 
  labs(title = "4-week PDC with March start", x = "Year", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0.5,1)) 
cma5_march_data <- cma5_march$data_summary
march_its <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = cma5_march_data)
summary(march_its)


```

They look very similar whether April or March used. Also looks similar in terms of beta values and overall (lack of) trends when we re-center 0 to peoples' first fill after COVID.

#### Fourier

```{r}
#| echo: true
#| warning: false
#| label: its-fourier

COVID_start <- as.Date("2020-03-11", format = "%Y-%m-%d")
cma5_original <- readRDS("./data/pdc-cma5.rds")

cma5_data <- cma5_original %>%
      mutate(adherent = case_when(
      CMA >= 0.80 ~ 1,
      CMA < 0.80 ~ 0)) %>%
    group_by(window.ID, window.start) %>%
    reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            # TODO run CMAs again, updated to mean() because of NAs
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA) %>%
    mutate(post_COVID = if_else(window.start >= COVID_start, 1, 0)) %>%
    distinct()
  
# window.ID is time variable
# install.packages("tsModel")
library(tsModel)
# nfreq = pairs of sin and cosine pairs
# period is length: doing 13 for 13 x 4 weeks = 52 weeks (1 year)
# BUT COVID time period isn't specified
# cma5_fourier <- harmonic(cma5_data$window.ID, nfreq = 2, period = 13)

cma5_data$week <- rep(1:13, length.out = 52)

# example has month repeating 1-12 separately from time elapsed
its_fourier <- glm(prop_adherent ~ window.ID + post_COVID + harmonic(week,2,13), family = "gaussian", data = cma5_data)

summary(its_fourier)
  
cma5_data$fourierfit <- predict(its_fourier)

ggplot(cma5_data, aes(x = window.start, y = prop_adherent)) +
    geom_point() + geom_line() +
    geom_line(aes(y = fourierfit), colour = "blue", linewidth = 1) +
    geom_vline(xintercept = COVID_start, colour = "red") +
  labs(title = "Fourier", x = "Year", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0.5,1)) 
```

For now, just trying what I think is 2 waves each year (13 x 4 weeks = 52 weeks) and I think we'd be looking for change between periods ?, but not very different. Looks like there is a change over time though.

#### Spline

```{r}
#| echo: true
#| warning: false
#| label: its-spline

COVID_start <- as.Date("2020-04-01", format = "%Y-%m-%d")
# cma5_original <- readRDS("./data/pdc-cma5.rds")

cma5_data <- cma5_original %>%
      mutate(adherent = case_when(
      CMA >= 0.80 ~ 1,
      CMA < 0.80 ~ 0)) %>%
    group_by(window.ID, window.start) %>%
    reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            # TODO run CMAs again, updated to mean() because of NAs
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA) %>%
    mutate(post_COVID = if_else(window.start >= COVID_start, 1, 0)) %>%
    distinct()
# window.ID is time variable

cma5_plot + geom_line()

library(splines)

# Dominici et al., cited by Bhaskaran et al.
# pandemic start is after window.ID 30 
# df = # knots/year x 4 years - 1 
cma5_sp <- bs(cma5_data$window.ID, degree = 3, df = 11)

its_sp <- glm(prop_adherent ~ cma5_sp, data = cma5_data, family = "gaussian")
  
cma5_data$sp_fit <- predict(its_sp)

Jan1 <- as.Date("2018-01-01", format = "%Y-%m-%d")
lastweek <- as.Date("2021-11-29", format = "%Y-%m-%d")
knots <- seq(from = Jan1, to = lastweek, length.out = 12)

ggplot(cma5_data, aes(x = window.start, y = prop_adherent)) +
    geom_point() + geom_line() +
    geom_line(aes(y = sp_fit), colour = "blue", linewidth = 1) +
    geom_vline(xintercept = COVID_start, colour = "red") +
  geom_vline(xintercept = knots, color = "black") +
  labs(title = "11 df", x = "Year", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0.5,1)) 

summary(its_sp)
```

For 11 df, meaning 12 knots, and pandemic is during knot 7. Can I compare this knot 7 to same 4 weeks in previous year?

Splines: fitting a cubic spline; they seem standard and are robust. For *k* knots, use *k*+1 degrees of freedom.

```{r}

# trying to see if mean is stationary. if stationary, can use ARIMA.
cma5diff <- diff(cma5_data, differences = 1)
```

#### Subsetting

Workflow for subsetting:

1.  create list of StudyIDs to filter on
2.  filter the cma output by StudyIDs from above
3.  optional but do the run_CMA function to summarize, do ITS, and plot

```{r}
#| echo: true
#| warning: false 
#| label: subsets
# demographic and clinical info 
demo <- study_pop %>%
  group_by(StudyID) %>%
  slice(n()) %>%
  select(StudyID, CTCDATE_OF_DIAGNOSIS_YYYY, ERstatus, stage_summary, drug_group, sex:reporting_source) 

pdc_white <- demo %>%
  filter(race_collapsed == "White") %>%
  left_join(cma5_original, by = "StudyID") %>%
  get_cma_results(april_start)

pdc_white$reg_summary
pdc_white$reg_plot + 
labs(title = "White race 4-week PDC", x = "Year", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0.5,1)) 


```

Overall, the betas are pretty much 0.

![Figure from Turner et al.](./data/TurnerFigure1.png)

Trying to set time 0 to the first fill post-pandemic and re-align. Not quite interrupted time series... but same principle applies. X axis will vary depending on when fills are in that time. Not sure if I should run CMA's separately for before and after? For now, just using the same output and reshaping.

```{r}
#| echo: true
#| warning: false
#| label: new-zero-time

# TODO sort out people missing from this cma? 200ish 
# missing several thousand. might be related to OW creation.
# cma5_original <- read_rds("./data/pdc-cma5.rds")
Jan1 <- as.Date("2018-01-01", format = "%Y-%m-%d") 
COVID_start <- as.Date("2020-03-11", format = "%Y-%m-%d")
COVID_week <- as.integer((difftime(COVID_start, Jan1, units ="weeks"))/4)

covid_IDs <- study_pop %>%
  group_by(StudyID) %>%
  filter(dispense_dt >= COVID_start) %>%
  arrange(dispense_dt) %>%
  slice_head(n = 1) %>%
  mutate(post_dispense = dispense_dt,
         post_dispense_end = post_dispense + days_supply,
         post_weekID = as.integer(floor(difftime(post_dispense_end, Jan1, units ="weeks"))/4),
         last_supply = days_supply) %>%
  select(StudyID, post_dispense, post_dispense_end, post_weekID, last_supply)

IDlist <- study_pop %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
   summarise(first_dispense = min(dispense_dt),
          last_dispense = max(dispense_dt),
          days_supply = last(days_supply)) %>%
  mutate(OW_end = last_dispense + days_supply + 30,
         OW_duration = as.integer(ceiling((difftime(OW_end, "2018-01-01", units = "weeks"))/4) * 4)) %>%
  select(StudyID, first_dispense, last_dispense, OW_end, OW_duration)

cma5_new <- cma5_original %>%
  left_join(covid_IDs, by = "StudyID") %>%
  mutate(post_weekID = if_else(is.na(post_weekID), COVID_week, post_weekID)) %>%
# added this to get a sense of first dispense dates
  left_join(IDlist, by = "StudyID") 
```

In order to do this pre/post comparison, may need to subset to people who have prescriptions before and after. For now, setting COVID as time 0 if they do not have it.

```{r}
#| echo: true
#| warning: false
#| label: new-zero-continued

cma5_new0 <- cma5_new %>%
    mutate(adherent = case_when(
    CMA >= 0.80 ~ 1,
    CMA < 0.80 ~ 0),
    new_window_ID = window.ID - post_weekID) %>% 
    # grouping by new window ID to align everyone's time 0 
  group_by(new_window_ID) %>%
  reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA,
          post_COVID = if_else(new_window_ID >= 0, 1, 0)) %>%
  distinct()

its_cma5_new0 <- lm(prop_adherent ~ new_window_ID + post_COVID + new_window_ID*post_COVID, data = cma5_new0)
summary(its_cma5_new0)
# have 12 missing

# omitting the time windows that are missing prop_adherent
cma5_new2 <- cma5_new0 %>% na.omit(prop_adherent) %>%
  mutate(total_count = adherent_count + non_adherent_count + adherent_NA_count)
  
cma5_new2$fit <- predict(its_cma5_new0)

plot_COVID_centered <- ggplot(cma5_new2, aes(x = new_window_ID, y = prop_adherent)) +
  geom_point() +
  geom_line(aes(y = fit), colour = "blue", linewidth = 1) +
  geom_vline(xintercept = 0, colour = "red") +
  labs(title = "4-week PDC (CMA5)", x = "Weeks relative to first post-pandemic prescription end", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0.5,1)) 

cma5_plot / cma5_april_plot / plot_COVID_centered
summary(april_its)
summary(march_its)
summary(its_cma5_new0)
```

Overall, they look similar: between March vs. April start vs. resetting everyone to first prescription post-COVID (independent of calendar year). For now, may stick to March or April. The other way is hard to interpret.

Curious what happens if we subset to only those who have a first dispense before pandemic.

```{r}
#| echo: true
#| warning: false
#| label: rx-preCOVID

cma5_post_subset <- cma5_original %>%
  left_join(IDlist, by = "StudyID") %>%
  filter(first_dispense < COVID_start) 

# n_distinct(cma5_post_subset$StudyID) 
# 7396... so most patients did start before pandemic 
cma5_post_summary <- cma5_post_subset %>%
    mutate(adherent = case_when(
    CMA >= 0.80 ~ 1,
    CMA < 0.80 ~ 0)) %>%
    # grouping by new window ID to align everyone's time 0 
  group_by(window.ID, window.start) %>%
  reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA,
          post_COVID = if_else(window.start >= COVID_start, 1, 0)) %>%
  distinct()

its_cma5_subset <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = cma5_post_summary)
summary(its_cma5_subset)

cma5_post_summary$fit <- predict(its_cma5_subset)
COVID_window <- as.Date("2020-03-23", format = "%Y-%m-%d")
ggplot(cma5_post_summary, aes(x = window.start, y = prop_adherent)) +
  geom_point() +
  geom_line(aes(y = fit), colour = "blue", linewidth = 1) +
  geom_vline(xintercept = COVID_start, colour = "red") +
  labs(title = "4-week PDC (CMA5)", x = "Time", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0.5,1)) 
```

Again, looks similar to before.

**References**

Dima, A.L., Dediu, D., 2017. Computation of adherence to medication and visualization of medication histories in R with AdhereR: Towards transparent and reproducible use of electronic healthcare data. PLoS One 12, e0174426. https://doi.org/10.1371/journal.pone.0174426

Turner, S.L., Karahalios, A., Forbes, A.B., Taljaard, M., Grimshaw, J.M., McKenzie, J.E., 2021. Comparison of six statistical methods for interrupted time series studies: empirical evaluation of 190 published series. BMC Medical Research Methodology 21, 134. https://doi.org/10.1186/s12874-021-01306-w

Vollmer, W.M., Xu, M., Feldstein, A., Smith, D., Waterbury, A., Rand, C., 2012. Comparison of pharmacy-based measures of medication adherence. BMC Health Serv Res 12, 155. https://doi.org/10.1186/1472-6963-12-155

```{r}
#| eval: false
#| echo: false
#| label: old-testing-code

# Code used to compare the CMAs and test the CMA function.
# random sample to compare CMAs
# note that StudyID = 3 is excluded actually 
test_dataset <- studydata %>%
   filter(StudyID %in% c(3, 6, 9, 12, 10652, 32672, 38858, 9354, 40148)) %>%
   select(StudyID, dispense_dt, days_supply, drug_group, daily_dose, AETdrug) %>%
  group_by(StudyID) %>%
    arrange(dispense_dt, .by_group = TRUE) %>%
    mutate(dispense_end = as.Date(dispense_dt + days_supply),
         next_dispense = lead(dispense_dt, default = NULL),
         days_interval = as.integer(difftime(next_dispense, dispense_dt, units = "days")),
         MPR = days_supply/(days_interval),
         capped_MPR = pmin(MPR, 1, na.rm = FALSE)
         ) %>%
  ungroup() 

ID_test <- test_dataset %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
   summarise(first_dispense = min(dispense_dt),
          last_dispense = max(dispense_dt),
          days_supply = last(days_supply)) %>%
  mutate(OW_end = last_dispense + days_supply + 90,
         OW_duration = as.integer(ceiling((difftime(OW_end, "2018-01-01", units = "weeks"))/4) * 4)) %>%
  select(StudyID, first_dispense, last_dispense, OW_end, OW_duration)

test2 <- test_dataset %>%
  inner_join(ID_test, by = "StudyID")

FU_start <- as.Date("2017-10-09", format = "%Y-%m-%d") 
FU_end <- as.Date("2022-01-01", format = "%Y-%m-%d")
FU_dur <- as.integer(difftime(FU_end, FU_start, units = "weeks"))

test_results <- test2 %>%
  group_by(StudyID) %>%
  do(run_CMA(., "CMA7", FU_start, FU_dur)) 

```

Started to try to calculate MPR myself... didn't get very far. If I were to would:

-   first for each patient, get MPR for each dispense date (and then set a min MPR, 1 - capped variable) then then later create dates dataset that seeks if there is an MPR in that week, to use it. THEN can add a check that if there was an MPR within 90 days it is 0, and if not it is NA. because those people are still in treatment episode.

    -   group by studyID and get +/- 1 event in dispenses

-   loop through each week, seek for dispense date within that week. - carry over based on days supply

```{r}
#| eval: false
#| label: DIY

whatever <- studypopdata %>%
   filter(StudyID %in% c(3, 6, 9, 12, 216, 1330, 6288, 18857, 22120)) %>%
   select(StudyID, dispense_dt, days_supply, drug_group, daily_dose, AETdrug) 

new_test <- whatever %>%
  arrange(StudyID, dispense_dt) %>%
  group_by(StudyID) %>%
# lead picks next date. Default is for last variable
# TODO revisit what the last variable should be if not null for last window. 
  mutate(dispense_end = as.Date(dispense_dt + days_supply),
         next_dispense = lead(dispense_dt, default = NULL),
         days_interval = as.integer(difftime(next_dispense, dispense_dt, units = "days")),
         MPR = days_supply/(days_interval),
         capped_MPR = pmin(MPR, 1, na.rm = FALSE)
         ) %>%
  ungroup()

months_df <- data.frame(date = seq(as.Date("2018-01-01"), as.Date("2021-12-01"), by = "month")) %>%
  mutate(month_year = format(date, "%Y-%m"))

new_attempt <- whatever %>%
  mutate(month_year = format(dispense_dt, "%Y-%m")) %>%
  full_join(months_df, by = "month_year") %>%
  mutate(MPR = if_else(between(day(dispense_dt), 1, 15) | between(day(dispense_end), 1, 15), capped_MPR, NA_real_)) 
```
