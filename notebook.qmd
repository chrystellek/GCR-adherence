---
title: "CMAsandbox"
format: docx
editor: visual
editor_options: 
  chunk_output_type: console
---

# Notebook

Chrystelle Kiang

```{r}
#| echo: true
#| warning: false
#| label: setup

library(here) 
library(tidyverse)
library(AdhereR)
library(patchwork)
library(gtsummary)

# import study dataset (created in data creation.R file) 
studypopdata <- readRDS("studypopdata.rds")
```

2024-2-4: The study population dataset has:

-   everyone eligible based on year of diagnosis and stage

-   pharmacy claims for patients whose ID matches for AI and Tamoxifen

There are extra people who do not have pharm data, can report those #s later. Created an "elig_rx" variable to flag those who have an rx after 2015. I think the patients with dispenses before diagnosis may be recurrences; will delete.

```{r}
# subset to those with prescription after their diagnosis date
studypopdata <- studypopdata %>%
  mutate(daily_dose = 1, # creating daily dose variable for AdhereR
         # combined diagnosis date variable 
         dt_diagnosis = as.Date(
           paste(CTCDATE_OF_DIAGNOSIS_YYYY,
           sprintf("%02d", as.numeric(CTCDATE_OF_DIAGNOSIS_MM)),
           sprintf("%02d", as.numeric(CTCDATE_OF_DIAGNOSIS_DD)),
           sep = "-"),
         format = "%Y-%m-%d")) 

rx_before_dx <- studypopdata %>%
  filter(dispense_dt <= dt_diagnosis) %>%
    distinct(StudyID, .keep_all = TRUE)

studydata <- studypopdata %>% 
  anti_join(rx_before_dx, by = "StudyID") %>%
  filter(!is.na(dispense_dt)) # only keep those with pharm info

studydata <- studydata %>%
  mutate(AETdrug = case_when(drug_group %in% c("AI","TAMOXIFEN") ~ "ET")) %>%
  filter(dispense_dt >= as.Date("2017-09-01", format = "%Y-%m-%d")) %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
  ungroup()
# changing this to dispense date 3 months before Jan 01 2018 for calculating MPR for month of Jan .

```

2-6-2024:

-   RE: People with both drug groups: there are valid reasons that people would switch. 1) AI to TAM for pre-meno who then start menopause. 2) TAM to AI if postmeno have bad side effects

-   Prescription before diagnosis date: some people are prescribed TAM to shrink tumor before surgery.

    -   Q of whether the date of diagnosis may be overridden at surgery (vs. biopsy)

    -   Q about tumor record number vs. "succession" number for repeated tumors

    -   TLL thinks it's odd that 0 bilateral

-   Can combine medication, no need to keep AI and TAM separately -- should include all drugs

AdhereR Package CMA1 and CMA2 map to MPR.

-   Continuous Medication Availability (CMA)

    -   CMA1 is the total days supply, excluding last dispense event, in observation window/duration between first to last dispense event.

$CMA1 = \frac{# days supply excluding last event}{first to last event}$

-   CMA2 is similar to CMA1 but *includes* last dispense event and time is based on the observation window (OW) specified. Not sure how the OW works when CMA2 used with sliding window. Package authors say that CMA2 includes duration of last event in numerator, and duration between start of last event to end of OW in denominator, which accounts for medication event happening before/after previous supply is finished.

$CMA2 = \frac{# days supply including last event}{first event to observation window end}$

-   CMA3 is CMA1 capped at 1.0

-   CMA4 is CMA2 capped at 1.0

-   CMA7 is \# days theoretical use/observation window period, where gap days between dispenses are not included in time interval; so this allows for carryover and excludes the left over supply

-   CMA8 is \# days theoretical use/observation window *with lagged start*, where gap days are not included in time interval, and the lag is the days of carry over supply

-   CMA9 is (# observation window days weighted by ratio of days supply)/observation window. This means carry over and extra supply is evenly spread until next event. Using this with sliding window presents an issue because it assigns a CMA to periods when the patient should be NA/too long after their episode has ended. It is good at estimating a CMA during gaps though; it's not perfect but ultimately less than 80% which is what really matters.

Update Feb 7: I think CMA4 is better because CMA1 (thus CMA3) assumes new dispense occurs after previous dispense occured. CMA2 (and thus CMA4) "includes the duration of the last event in the numerator and the period from the last event to the end of the OW in the denominator" (according to package documentation). I am assuming OW = sliding window set.

Update Jan 23: after discussion with Tim, CMA3 or CMA4 are probably appropriate and more likely. My thought is that I'm wasting time trying to compare these measures and should just stick to CMA3... assuming that the sliding window addresses any overlaps or gaps in prescriptions.

Jan 2024: CMA1 and CMA2 produced MPRs WAY over 1. So compared CMA3 and CMA4 which are capped at 1.0 (Jan 23). Did some rough estimates to compare the CMAs... (see previous version of code) and CMA3 and CMA4 really do tend towards 1 while CMA7 and CMA9 have much lower means?? Perhaps need to plot over time though. CMA3 and CMA4 have more missings though while CMA7 and CMA9 still provide some estimate.

Feb 19: After reading more into Vollmer et al. (2012), I am not convinced that MPR is what we want to plot. MPR seems to be better suited for longer intervals rather than what we're trying to consider. Proportion of days covered may actually be of interest? Vollmer suggests MDC is more indicator of medication dispense/whether refills obtained, which is what we're interested in as well though... New plan is to look at 1) MPR for 3 months and 2) PDC for 1 week or 1 month

2/17: Current challenge is sorting difference between missing CMA and 0 (during gaps)

Feb 8: I think CMAs are too sporadic and most are close to 1 to see a big difference overall, so next I want to look at proportion adherent for each time period... I suspect that the \# of people per time period may change. BUT i'm not sure how to properly account for missings (lost to follow up or died). These are all inital dispenses of 2018 so *should* be within \[prescription\] window. \[there is a better word but I can't think of it atm\]. Additional update is that I had previously coded time (in days) after COVID wrong so now getting similar results when we look at week vs. day!! Yay! Weekly below.

TODO: censor patients with only one dispense

possibilites - search for last dispense date, reset CMA to NA days after last dispense + 30 or 90 days, and manually set to 0 if still within dispense windows. would need to either loop through each paitent... or create first and last dispense date variables in studyID dataset used to copy studyID back - (CMA9 has a running tally of days leftover in inner event info...)

-   for each week, run CMA for each patient and later combine those. will be inefficient.

Testing CMA function

```{r}
#| echo: true
#| eval: false
#| warning: false
#| label: CMA-sandbox

# function to run CMA... 

run_CMA <- function(data, cma_choice, FU_start, FU_duration){
  OW_duration <- min(208, first(data$OW_duration))
  Jan1 <- as.Date("2018-01-01", format = "%Y-%m-%d") 
  
  cma <- CMA_sliding_window(CMA.to.apply = cma_choice,
                     data = data,
                     ID.colname = "StudyID",
                     event.date.colname = "dispense_dt",
                     event.duration.colname = "days_supply",
                     event.daily.dose.colname ="daily_dose",
                     medication.class.colname = "AETdrug",
                     carry.only.for.same.medication = FALSE,
                     consider.dosage.change = FALSE,
                     followup.window.start = FU_start,
                     followup.window.duration = FU_duration,
                     followup.window.duration.unit = "weeks",
                     observation.window.start = Jan1,
                     observation.window.duration = OW_duration,
                     observation.window.duration.unit = "weeks",
                     sliding.window.start = 0, 
                     sliding.window.start.unit = "weeks",
                     sliding.window.duration = 4,
                     sliding.window.duration.unit = "weeks",
                     # if window and step are same, there is no overlap
                     sliding.window.step.duration = 4,
                     sliding.window.step.unit = "weeks",
                     date.format = "%Y/%m/%d",
                     parallel.backend = "none",
                     parallel.threads = 1) 
  result <- as_tibble(cma$CMA)
  return(result)
}

# random sample to compare CMAs
# TODO assign the rest of these variables to studydata
test_dataset <- studydata %>%
   filter(StudyID %in% c(3, 6, 9, 12, 10652, 32672, 38858, 9354, 40148)) %>%
   select(StudyID, dispense_dt, days_supply, drug_group, daily_dose, AETdrug) %>%
  group_by(StudyID) %>%
    arrange(dispense_dt, .by_group = TRUE) %>%
    mutate(dispense_end = as.Date(dispense_dt + days_supply),
         next_dispense = lead(dispense_dt, default = NULL),
         days_interval = as.integer(difftime(next_dispense, dispense_dt, units = "days")),
         MPR = days_supply/(days_interval),
         capped_MPR = pmin(MPR, 1, na.rm = FALSE)
         ) %>%
  ungroup() 

ID_test <- test_dataset %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
   summarise(first_dispense = min(dispense_dt),
          last_dispense = max(dispense_dt),
          days_supply = last(days_supply)) %>%
  mutate(OW_end = last_dispense + days_supply + 90,
         OW_duration = as.integer(ceiling((difftime(OW_end, "2018-01-01", units = "weeks"))/4) * 4)) %>%
  select(StudyID, first_dispense, last_dispense, OW_end, OW_duration)

test2 <- test_dataset %>%
  inner_join(ID_test, by = "StudyID")

FU_start <- as.Date("2017-10-09", format = "%Y-%m-%d") 
FU_end <- as.Date("2022-01-01", format = "%Y-%m-%d")
FU_dur <- as.integer(difftime(FU_end, FU_start, units = "weeks"))

test_results <- test2 %>%
  group_by(StudyID) %>%
  do(run_CMA(., "CMA7", FU_start, FU_dur)) 

# TODO update will full dataset

# 1. set study period 
# technically, follow up starting 16 weeks before study period to allow for previous fill
FU_start <- as.Date("2017-10-09", format = "%Y-%m-%d") 
COVID_start <- as.Date("2020-03-11", format = "%Y-%m-%d")
FU_end <- as.Date("2022-01-01", format = "%Y-%m-%d")
FU_dur <- as.integer(difftime(FU_end, FU_start, units = "weeks"))
# 2. get each person's overall persistent episode and IDs
# TODO revisit start date to allow for the fills right before 1/1/18 
IDlist <- studydata %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
   summarise(first_dispense = min(dispense_dt),
          last_dispense = max(dispense_dt),
          days_supply = last(days_supply)) %>%
  mutate(OW_end = last_dispense + days_supply + 30,
         OW_duration = as.integer(ceiling((difftime(OW_end, "2018-01-01", units = "weeks"))/4) * 4)) %>%
  select(StudyID, first_dispense, last_dispense, OW_end, OW_duration)
# TODO later keep more variables for subgroup analyses

study_run <- studydata %>%
  inner_join(IDlist, by = "StudyID")

# run function for each participant
results_full <- study_run %>%
  group_by(StudyID) %>%
  do(run_CMA(., "CMA7", FU_start, FU_dur)) 
# got some warnings about patients who don't have dispenses during FU and obs... not sure if that is worth subsetting at some point in study data - maybe filtering out in the IDs who have dispenses? 
######
```

TODO: create a variable to indicate very last dispense date (+90 days)

Looking at a handful of patients, raw data vs. different CMAs and different windows.

\| CMA \| FU \| window \| notes \|

\|----:\|:---:\|:------:\|:---------\|

\| 7 \| 1/1/18 \| 4 wks/4wks \| this does seem to get what I want. Just marks 0 long after treatment window, may need to then go back and NA those \|

\| 9 \| 1/1/18 \| 30/30 \| some CMA counted as 1 when dosages don't seem that way, maybe from carry-over? \|

\| 4 \| 1/1/18 \| 30/30 \| marks NA when window does not contain dispense date \|

\| 3 \| 1/1/18 \| 30/30 \| seems to mark NA when window doesn't contain dispense date \|

Feb 9: TODO is have figure \# assigned to each chunk, figure out Quarto.

Feb 13: Ask Anke, Kevin, Tim about ITS thoughts. Specifically:

1.  Should we use this vs. splines? smoothing?
2.  Should the two points be constrained to be equal at time of intervention

### Interrupted Time Series

I've seen two versions of interrupted time series formulas:

-   Option 1: Y \~ $\beta_{0}$time + $\beta_{1}$COVID + $\beta_{2}$time since COVID start

-   Option 2: Y \~ $\beta_{0}$time + $\beta_{1}$COVID + $\beta_{2}$time \* COVID

where:

-   $\beta_{1}$ = trend before COVID

-   $\beta_{2}$ = level of change right after start of COVID

-   $\beta_{3}$ = trend after COVID

Option 1 below:

```{r}
#| echo: true
#| warning: false
#| label: weekly-its

IDs <- studydata %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
  slice(n()) %>%
  ungroup() %>%
  rename(last_dispense = dispense_dt)

FU_start <- as.Date("2018-01-01", format = "%Y-%m-%d") 
COVID_start <- as.Date("2020-03-11", format = "%Y-%m-%d")
FU_end <- as.Date("2021-12-31", format = "%Y-%m-%d")
COVID_start_week <- as.integer(difftime(COVID_start, FU_start, units = "weeks"))
pandemic_start_week <- as.integer(difftime(COVID_start, FU_start, units = "weeks"))

#TODO left off HERE
new_results <- results_full %>%
    mutate(adherent = case_when(
    CMA >= 0.80 ~ 1,
    CMA < 0.80 ~ 0)) %>%
  group_by(window.ID, window.start) %>%
  reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            prop_adherent = adherent_count/(adherent_count + non_adherent_count),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA) %>%
  mutate(post_COVID = if_else(window.start >= COVID_start, 1, 0))

new_results %>% select(prop_adherent, window.ID) %>%
  tbl_summary(by = window.ID)

# TODO: figure out proportion adherent counts and how missings handled 
# people with shorter OW will NOT have missings after their OW end, but DO have missings before first dispense  

its <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = new_results)
summary(its)

new_results$fit <- predict(its)

ggplot(new_results, aes(x = window.start, y = prop_adherent)) +
  geom_point() +
  geom_line(aes(y = fit), colour = "blue", linewidth = 1) +
  geom_vline(xintercept = COVID_start, colour = "red") +
  labs(title = "4-week PDC (CMA7)", x = "Year", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0,1), expand = c(0, 0)) 

tbl_regression(its)
############################################

```

Testing other cases below

```{r}
#| eval: false
#| warning: false
#| label: testing-ITS

# Case 2. MPR, 12 weeks
MPR12 <- MPR_12weeks %>%
  left_join(IDs, by = "StudyID") %>%
  mutate(adherent = case_when(
    CMA >= 0.80 ~ 1,
    CMA < 0.80 ~ 0)) 

MPR12 <- MPR12 %>%
  group_by(window.start) %>%
  mutate(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA,
            post_COVID = if_else(window.start >= COVID_start, 1, 0)) %>%
  ungroup() 

its_MPR12weeks <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = MPR12)
summary(its_MPR12weeks)

MPR12$fit <- predict(its_MPR12weeks)

MPR12_plot <- 
  ggplot(MPR12, aes(x = window.start, y = prop_adherent)) +
  geom_point() +
  geom_line(aes(y = fit), colour = "blue", linewidth = 1) +
  geom_vline(xintercept = COVID_start, colour = "red") +
  labs(title = "12-week MPR", x = "Week", y = "Proportion Adherent (80%)") 

MPR12_NA_plot <- 
  ggplot(MPR12, aes(x = window.start, y = prop_NA)) +
  geom_point() + 
  geom_vline(xintercept = COVID_start, colour = "red") +
  labs(x = "Week", y = "Proportion Missing")

MPR12_plot / MPR12_NA_plot

# Case 3. Proportion Days Covered, 4 weeks
PDC_4weeks <- PDC_4weeks %>%
  left_join(IDs, by = "StudyID") %>%
  mutate(adherent = case_when(
    CMA >= 0.80 ~ 1,
    CMA < 0.80 ~ 0)) 

PDC_4weeks <- PDC_4weeks %>%
  group_by(window.start) %>%
  mutate(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA,
            post_COVID = if_else(window.start >= COVID_start, 1, 0)) %>%
  ungroup() 

its_PDC4weeks <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = PDC_4weeks)
summary(its_PDC4weeks)

PDC_4weeks$fit <- predict(its_PDC4weeks)

#PDC4_plot <- 
  ggplot(PDC_4weeks, aes(x = window.start, y = prop_adherent)) +
  geom_point() +
  geom_line(aes(y = fit), colour = "blue", linewidth = 1) +
  geom_vline(xintercept = COVID_start, colour = "red") +
  labs(title = "4-week Prop Days Covered (PDC)", x = "Week", y = "Proportion Adherent (80%)") 

#PDC4_NA_plot <- 
  ggplot(PDC_4weeks, aes(x = window.start, y = prop_NA)) +
  geom_point() + 
  geom_vline(xintercept = COVID_start, colour = "red") +
  labs(x = "Week", y = "Proportion Missing")
  
################

# deleting after treatment ends
PDC_4weeks_clean <- PDC_4weeks %>%
  group_by(StudyID) %>%
  mutate(CMA2 = CMA,
         CMA2 = if_else(
           difftime(last_dispense, window.start, units = "days") > 90, NA_real_, CMA2)) %>% 
  ungroup() %>%
  mutate(adherent = case_when(
    CMA2 >= 0.80 ~ 1,
    CMA2 < 0.80 ~ 0)) %>%
    group_by(window.start) %>%
  mutate(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA,
            post_COVID = if_else(window.start >= COVID_start, 1, 0)) %>%
  ungroup() 

its_PDC4weeks2 <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = PDC_4weeks_clean)
summary(its_PDC4weeks2)

PDC_4weeks_clean$fit <- predict(its_PDC4weeks2)

#PDC4_plot <- 
  ggplot(PDC_4weeks_clean, aes(x = window.start, y = prop_adherent)) +
  geom_point() +
  geom_line(aes(y = fit), colour = "blue", linewidth = 1) +
  geom_vline(xintercept = COVID_start, colour = "red") +
  labs(title = "4-week Prop Days Covered (PDC)", x = "Week", y = "Proportion Adherent (80%)") 

#PDC4_NA_plot <- 
  ggplot(PDC_4weeks_clean, aes(x = window.start, y = prop_NA)) +
  geom_point() + 
  geom_vline(xintercept = COVID_start, colour = "red") +
  labs(x = "Week", y = "Proportion Missing")
  
############## 
# CMA5
PDC5 <- PDC5_4weeks %>%
  left_join(IDs, by = "StudyID") %>%
  group_by(StudyID) %>%
  mutate(CMA2 = CMA,
         CMA2 = if_else(
           difftime(last_dispense, window.start, units = "days") > 90, NA_real_, CMA2)) %>% 
  ungroup() %>%
  mutate(adherent = case_when(
    CMA2 >= 0.80 ~ 1,
    CMA2 < 0.80 ~ 0)) %>%
  group_by(window.start) %>%
  mutate(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            prop_adherent = mean(adherent, na.rm = TRUE),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA,
            post_COVID = if_else(window.start >= COVID_start, 1, 0)) %>%
  ungroup() 

its_PDC5 <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = PDC5)
summary(its_PDC5)

PDC5$fit <- predict(its_PDC5)

#PDC4_plot <- 
  ggplot(PDC_4weeks_clean, aes(x = window.start, y = prop_adherent)) +
  geom_point() +
  geom_line(aes(y = fit), colour = "blue", linewidth = 1) +
  geom_vline(xintercept = COVID_start, colour = "red") +
  labs(title = "4-week Prop Days Covered (PDC)", x = "Week", y = "Proportion Adherent (80%)") 

#PDC4_NA_plot <- 
  ggplot(PDC_4weeks_clean, aes(x = window.start, y = prop_NA)) +
  geom_point() + 
  geom_vline(xintercept = COVID_start, colour = "red") +
  labs(x = "Week", y = "Proportion Missing")

```

Feb 8: Now created a new dataset that has time as weeks and has CMA and adherence/proportion adherent per week. Maybe worth turning this process into a function since I eventually want to look at these measures among subsets of population. Workflow would be subset -\> pass through function -\> get results

May try to calculate MPR myself. Can either:

-   first for each patient, get MPR for each dispense date (and then set a min MPR, 1 - capped variable) then then later create dates dataset that seeks if there is an MPR in that week, to use it. THEN can add a check that if there was an MPR within 90 days it is 0, and if not it is NA. because those people are still in treatment episode.

    -   group by studyID and get +/- 1 event in dispenses

-   loop through each week, seek for dispense date within that week. - carry over based on days supply

```{r}
#| echo: false
#| eval: false
#| warning: false
#| label: DIY

whatever <- studydata %>%
   filter(StudyID %in% c(3, 6, 9, 12, 216, 1330, 6288, 18857, 22120)) %>%
   select(StudyID, dispense_dt, days_supply, drug_group, daily_dose, AETdrug) 

new_test <- whatever %>%
  arrange(StudyID, dispense_dt) %>%
  group_by(StudyID) %>%
# lead picks next date. Default is for last variable
# TODO revisit what the last variable should be if not null for last window. 
  mutate(dispense_end = as.Date(dispense_dt + days_supply),
         next_dispense = lead(dispense_dt, default = NULL),
         days_interval = as.integer(difftime(next_dispense, dispense_dt, units = "days")),
         MPR = days_supply/(days_interval),
         capped_MPR = pmin(MPR, 1, na.rm = FALSE)
         ) %>%
  ungroup()

months_df <- data.frame(date = seq(as.Date("2018-01-01"), as.Date("2021-12-01"), by = "month")) %>%
  mutate(month_year = format(date, "%Y-%m"))

new_attempt <- whatever %>%
  mutate(month_year = format(dispense_dt, "%Y-%m")) %>%
  full_join(months_df, by = "month_year") %>%
  mutate(MPR = if_else(between(day(dispense_dt), 1, 15) | between(day(dispense_end), 1, 15), capped_MPR, NA_real_)) 


```
