---
title: "CMAsandbox"
format: docx
editor: visual
editor_options: 
  chunk_output_type: console
---

# Notebook

Notebook for dissertation aim looking at medication use (adherence and maybe persistence?) during pandemic.

Chrystelle Kiang

```{r}
#| echo: true
#| warning: false
#| label: setup

library(here) 
library(tidyverse)
library(AdhereR)
library(gtsummary)

# import study dataset (created in data creation.R file) 
studypopdata <- readRDS("studypopdata.rds")
```

2024-2-4: The study population dataset has:

-   everyone eligible based on year of diagnosis and stage

-   pharmacy claims for patients whose ID matches for AI and Tamoxifen

There are extra people who do not have pharm data, can report those #s later. Created an "elig_rx" variable to flag those who have an rx after 2015. I think the patients with dispenses before diagnosis may be recurrences; will delete.

```{r}
# subset to those with prescription after their diagnosis date
studypopdata <- studypopdata %>%
  mutate(daily_dose = 1, # creating daily dose variable for AdhereR
         # combined diagnosis date variable 
         dt_diagnosis = as.Date(
           paste(CTCDATE_OF_DIAGNOSIS_YYYY,
           sprintf("%02d", as.numeric(CTCDATE_OF_DIAGNOSIS_MM)),
           sprintf("%02d", as.numeric(CTCDATE_OF_DIAGNOSIS_DD)),
           sep = "-"),
         format = "%Y-%m-%d")) 

# want to get StudyIDs of those who have any rx before dx
# will then use that list to extract from studypopdata
# maybe can do this by grouping?
rx_before_dx <- studypopdata %>%
  filter(dispense_dt <= dt_diagnosis) %>%
    distinct(StudyID, .keep_all = TRUE)

studydata <- studypopdata %>% 
  anti_join(rx_before_dx, by = "StudyID") %>%
  filter(!is.na(dispense_dt)) # only keep those with pharm info

```

```{r}
#| include: false
## data exploration
# Exploring patients with both AI and TAM. See note below about this after discussion with Tim (2/6)
drugsbystudyID <- studydata %>%
  group_by(StudyID) %>%
  summarise(n_drug = n_distinct(drug_group)) 

doubles <- studydata %>%
  inner_join(drugsbystudyID, by = "StudyID") %>%
  filter(n_drug > 1)
  
ndrug <- as.matrix(table(drugsbystudyID$n_drug))
```

2-6-2024:

-   People with both drug groups: there are valid reasons that people would switch. 1) AI to TAM for pre-meno who then start menopause. 2) TAM to AI if postmeno have bad side effects

-   Prescription before diagnosis date: some people are prescribed TAM to shrink tumor before surgery.

    -   Q of whether the date of diagnosis may be overridden at surgery (vs. biopsy)

    -   Q about tumor record number vs. "succession" number for repeated tumors

    -   TLL thinks it's odd that 0 bilateral

-   Can combine medication, no need to keep AI and TAM separately -- should include all drugs

AdhereR Package CMA1 and CMA2 map to MPR.

-   Continuous Medication Availability (CMA)

    -   CMA1 is \# days supply excluding last dispense event/first to last dispense event

    -   CMA2 is similar to CMA1 but *includes* last dispense event and time is based on the observation window (OW) specified. Not sure how the OW works when CMA2 used with sliding window.

    -   CMA3 is CMA1 capped at 1.0

    -   CMA4 is CMA2 capped at 1.0

    -   CMA7 is \# days theoretical use/observation window period, where gap days between dispenses are not included in time interval; so this allows for carryover and excludes the left over supply

    -   CMA8 is \# days theoretical use/observation window *with lagged start*, where gap days are not included in time interval, and the lag is the days of carry over supply

    -   CMA9 is (# observation window days weighted by ratio of days supply)/observation window. This means carry over and extra supply is evenly spread until next event

```{r}
#| echo: true
#| warning: false
#| label: CMA

studydata <- studydata %>%
  mutate(AETdrug = case_when(drug_group %in% c("AI","TAMOXIFEN") ~ "ET")) %>%
  filter(dispense_dt >= as.Date("2018-01-01", format = "%Y-%m-%d")) %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
  ungroup()

slide_cma4 <- CMA_sliding_window(CMA.to.apply="CMA4", 
                                 data = studydata,
                                 ID.colname = "StudyID",
                                 event.date.colname = "dispense_dt",
                                 event.duration.colname = "days_supply",
                                 event.daily.dose.colname ="daily_dose",
                                 medication.class.colname = "AETdrug",
                                 carry.only.for.same.medication = FALSE,
                                 consider.dosage.change = FALSE,
                                 followup.window.start = 0,
                                 followup.window.duration = 4,
                                 followup.window.duration.unit = "years",
                                 observation.window.start = 0,
                                 observation.window.duration = 4,
                                 observation.window.duration.unit = "years",
                                 sliding.window.start = 0, 
                                 sliding.window.start.unit = "weeks",
                                 sliding.window.duration = 4,
                                 sliding.window.duration.unit = "weeks",
                                 # if window and step are same, there is no overlap
                                 sliding.window.step.duration = 4,
                                 sliding.window.step.unit = "weeks",
                                 date.format = "%Y/%m/%d",
                                 parallel.backend = "none",
                                 parallel.threads = 1)

cma4 <- as_tibble(slide_cma4$CMA) %>%
    filter(window.start <= as.Date("2022-07-01", format = "%Y-%m-%d"))

# ggplot(cma4, aes(x = window.start, y = CMA, group = StudyID)) + geom_line()
plot(slide_cma4, patients.to.plot = c(12, 930))

#TODO wondering if I can set start to a date for the sliding window
  # for now, subset studydata to 2018 so maybe that will be the FU start

IDs <- studydata %>%
  distinct(StudyID, .keep_all = TRUE) %>%
  select(-dispense_dt)

cma4 <- cma4 %>%
  full_join(IDs, by = "StudyID") %>%
  mutate(adherent = case_when(
    CMA >= 0.80 ~ 1,
    CMA < 0.80 ~ 0))
```

Update Feb 7: I think CMA4 is better because CMA1 (thus CMA3) assumes new dispense occurs after previous dispense occured. CMA2 (and thus CMA4) "includes the duration of the last event in the numerator and the period from the last event to the end of the OW in the denominator" (according to package documentation). I am assuming OW = sliding window set.

TODO Feb 6: Need to reconcile merging these two back together. Not sure if ITS can be done with different window dates that CMA outputs, or if I should create a new date that goes through and looks for next closest date and fills in or something.

Update Jan 23: after discussion with Tim, CMA3 or CMA4 are probably appropriate and more likely. My thought is that I'm wasting time trying to compare these measures and should just stick to CMA3... assuming that the sliding window addresses any overlaps or gaps in prescriptions.

Jan 2024: CMA1 and CMA2 produced MPRs WAY over 1. So compared CMA3 and CMA4 which are capped at 1.0 (Jan 23). Did some rough estimates to compare the CMAs... (see previous version of code) and CMA3 and CMA4 really do tend towards 1 while CMA7 and CMA9 have much lower means?? Perhaps need to plot over time though. CMA3 and CMA4 have more missings though while CMA7 and CMA9 still provide some estimate.

```{r}
#| echo: false
#| warning: false
#| label: daily

# Interupted Time Series Analysis
# follow up start
FU_start <- as.Date("2018-01-01", format = "%Y-%m-%d") 
COVID_start <- as.Date("2020-03-11", format = "%Y-%m-%d")
pandemy_start <- difftime(FU_start, COVID_start, units = "days")

cma4 <- cma4 %>%
  mutate(time_days = as.numeric(difftime(window.start, FU_start, units = "days")),
         post_COVID = if_else(window.start > COVID_start, 1, 0),
         time_passed_days = if_else(
           post_COVID == 1, as.numeric(difftime(window.start, COVID_start, units = "days")), 0)) 

its_reg <- lm(CMA ~ time_days + post_COVID + time_passed_days, data = cma4)
summary(its_reg)
# cma4_fit <- predict(its_reg)

ggplot(cma4, aes(x = time_days, y = CMA)) + geom_point() +
  geom_line(aes(y = fit), colour = "blue") + 
  geom_vline(xintercept = pandemy_start, colour = "red") + 
#  scale_x_continuous(expand = c(0, 0), limits = c(0, 1700)) +
#  scale_y_continuous(expand = c(0, 0), limits = c(0.5, 1)) +
  labs(x = "Time", y = "CMA") +  
  theme_classic() 
```

Feb 8: I think CMAs are too sporadic and most are close to 1 to see a big difference overall, so next I want to look at proportion adherent for each time period... I suspect that the \# of people per time period may change. BUT i'm not sure how to properly account for missings (lost to follow up or died). These are all inital dispenses of 2018 so *should* be within \[prescription\] window. \[there is a better word but I can't think of it atm\]. Additional update is that I had previously coded time (in days) after COVID wrong so now getting similar results when we look at week vs. day!! Yay! Weekly below.

I've seen two versions of interrupted time series formulas:

-   Option 1: Y \~ $\beta_{0}$time + $\beta_{1}$COVID + $\beta_{2}$time since COVID start

-   Option 2: Y \~ $\beta_{0}$time + $\beta_{1}$COVID + $\beta_{2}$time \* COVID

where:
- $\beta_{1}$ = trend before COVID
- $\beta_{2}$ = level of change right after start of COVID
- $\beta_{3}$ = trend after COVID 

Option 1 below:

```{r}
#| echo: true
#| warning: false
#| label: weekly-its

FU_start <- as.Date("2018-01-01", format = "%Y-%m-%d") 
COVID_start <- as.Date("2020-03-11", format = "%Y-%m-%d")
# some math to check weeks
FU_end <- as.Date("2022-07-01", format = "%Y-%m-%d")
# difftime(FU_end, FU_start, units = "weeks")

COVID_start_week <- as.integer(difftime(COVID_start, FU_start, units = "weeks"))
pandemy_start_week <- as.integer(difftime(COVID_start, FU_start, units = "weeks"))

cma4_weekly <- cma4 %>%
  mutate(time_weeks = as.numeric(difftime(window.start, FU_start, units = "weeks"))) 
# TODO need to solve how to make the last week a number and not be NA
cma4_weekly <- cma4_weekly %>%
  group_by(week = as.integer(cut(time_weeks, breaks = seq(0, max(time_weeks) + 1, by = 1), include.lowest = TRUE))) %>%
  reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            prop_adherent = mean(adherent, na.rm = TRUE),
            post_COVID_week = if_else(week >= COVID_start_week, 1, 0),
    time_passed_weeks = if_else(post_COVID_week == 1, week - COVID_start_week, 0)) %>%
  ungroup() %>%
  distinct()

its_reg_week <- lm(prop_adherent ~ week + post_COVID_week + time_passed_weeks, data = cma4_weekly)
summary(its_reg_week)

cma4_weekly$fit <- predict(its_reg_week)

weekly_plot <- ggplot(cma4_weekly, aes(x = week, y = prop_adherent)) +
  geom_point() +  
  geom_line(aes(y = fit), color = "blue", linewidth = 2) +
  geom_vline(xintercept = pandemy_start_week, colour = "red") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  labs(x = "Week", y = "Proportion Adherent (80%)") +  
  theme_classic() 

weekly_plot
```

Comparing that with dummy variable (Option 2)

```{r}
#| echo: true
#| warning: false
#| label: weekly-dummy

its2_weekly <- lm(prop_adherent ~ week + post_COVID_week + week*post_COVID_week, data = cma4_weekly)
summary(its2_weekly)

cma4_weekly2 <- cma4_weekly
cma4_weekly2$fit <- predict(its2_weekly)

comp1 <- ggplot(cma4_weekly2, aes(x = week, y = prop_adherent)) +
  geom_point() +  
  geom_line(aes(y = fit), color = "blue", linewidth = 2) +
  geom_vline(xintercept = pandemy_start_week, colour = "red") +
  labs(x = "Week", y = "Proportion Adherent (80%)") +  
  theme_classic() 
#  scale_x_continuous(expand = c(0, 0), limits = c(0, 1700)) +
 # scale_y_continuous(expand = c(0, 0), limits = c(0.5, 1)) +
weekly_plot
comp1

# TODO use gtsummary to make a nice table
tbl_its_week <- lm(prop_adherent ~ week + post_COVID_week + time_passed_weeks, data = cma4_weekly)
```

Feb 8: Now created a new dataset that has time as weeks and has CMA and adherence/proportion adherent per week. Maybe worth turning this process into a function since I eventually want to look at these measures among subsets of population. Workflow would be subset -\> pass through function -\> get results

Feb 9: TODO is have figure \# assigned to each chunk, figure out Quarto.

Feb 13: Ask Anke, Kevin, Tim about ITS thoughts. Specifically:

1.  Should we use this vs. splines? smoothing?
2.  Should the two points be constrained to be equal at time of intervention

TODO compare to 3 month adherence instead? 
