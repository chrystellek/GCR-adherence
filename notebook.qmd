---
title: "CMAsandbox"
format: docx
editor: visual
editor_options: 
  chunk_output_type: console
---

# Notebook

Chrystelle Kiang

```{r}
#| echo: true
#| warning: false
#| label: setup

library(here) 
library(tidyverse)
library(DiagrammeR)
library(AdhereR)
library(patchwork)
library(gtsummary)

# import study dataset (created in data creation.R file) 
studypopdata <- readRDS("studypopdata.rds")
```

The study population dataset has everyone eligible based on year of diagnosis and stage AND pharmacy claims for patients whose ID matches for AI and Tamoxifen. There are extra people who do not have pharm data, those #s will be reported in results.qmd.

```{r}
#| echo: true
#| warning: false
#| label: in-results

elig_pop <- pharmstudydata %>%
  distinct(StudyID, .keep_all = TRUE) 

# subset pts who have rx and those who have rx after diagnosis
rx_before_dx <- pharmstudydata %>%
  filter(dispense_dt <= dt_diagnosis) %>%
    distinct(StudyID, .keep_all = TRUE)

# number with prescriptions outside of study period
rx_before_study <- pharmstudydata %>%
  anti_join(rx_before_dx, by = "StudyID") %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
   summarise(last_dispense = max(dispense_dt)) %>%
  select(StudyID, last_dispense) %>%
  filter(!is.na(last_dispense),
         last_dispense < as.Date("2017-09-01", format = "%Y-%m-%d")) 

pop_no_rx <- pharmstudydata %>% 
  filter(is.na(dispense_dt)) %>%
      distinct(StudyID, .keep_all = TRUE)

study_pop <- pharmstudydata %>% 
  anti_join(rx_before_dx, by = "StudyID") %>%
  filter(!is.na(dispense_dt),
         dispense_dt >= as.Date("2017-09-01", format = "%Y-%m-%d")) %>%
  mutate(daily_dose = 1)
# changing this to dispense date 3 months before Jan 01 2018 for calculating MPR for month of Jan .
```

Below is code to test code that I'd like to put in results eventually.

```{r}
#| echo: true
#| eval: false
#| warning: false
#| label: testing

pharmstudydata <- pharmstudydata %>%
  mutate(final_study = ifelse(StudyID %in% study_pop$StudyID, 1, 0))

pop_info <- list(total_elig = n_distinct(elig_pop$StudyID),
                 no_rx = n_distinct(pop_no_rx$StudyID),
                 rx_predx = n_distinct(rx_before_dx$StudyID),
                 rx_prestudy = n_distinct(rx_before_study$StudyID),
                 total_study = n_distinct(study_pop$StudyID),
                 no_rx_percent = n_distinct(pop_no_rx$StudyID)/n_distinct(elig_pop$StudyID))

# flow chart
# TODO pass through variables vs. having to know numbers?
grViz("digraph flow_diagram{
  graph [layout = dot, rankdir = TB]
  node [shape = box]
  
  eligGA [label = 'Eligible\n']
  no_rx [label = 'Do not have pharmacy data']
  study_pop [label = 'Study population']
  blank[label = '', width = 0.01, height = 0.01]
  
  {rank = same; blank no_rx}
  
  eligGA -> blank[dir = none]
  blank -> no_rx[ minlen = 3 ]
  blank -> study_pop
}")

```

Notes from data cleaning:

-   **Drug groups:** There were some people with both drug groups (AI and TAM). There are valid reasons that people would switch. 1) AI to TAM for pre-meno who then start menopause. 2) TAM to AI if postmeno have bad side effects (Convo with Tim 2/6) --\> included both.

    -   Also decided to look at all adjuvant endocrine therapy as one category, at least for now, as opposed to AI and TAM separately (could do that later).

-   **Prescription timing:** Some had prescription before diagnosis date. People can be prescribed TAM to shrink tumor before surgery (neoadjuvant) -\> excluded them entirely.

    -   Open questions: what is the source for date of diagnosis? (E.g., is date of diagnosis overridden at surgery vs. biopsy to explain prescription *before* dx)

-   **Tumor record number:** Q about tumor record number vs. "succession" number for repeated tumors

    -   Tim thinks it's odd that 0 bilateral- still maybe related to tumor record number

**Continuous Medication Availability (CMA)**: AdhereR package, largely based on Vollmer et al.

-   CMA1 is the total days supply, excluding last dispense event, in observation window/duration between first to last dispense event.

-   CMA1 is total days supply, excluding last dispense event, in observation window/duration between first to last event.

-   CMA2 is similar to CMA1 but *includes* last dispense event and time is based on the observation window (OW) specified. Not sure how the OW works when CMA2 used with sliding window. Package authors say that CMA2 includes duration of last event in numerator, and duration between start of last event to end of OW in denominator, which accounts for medication event happening before/after previous supply is finished.

$$
CMA2 = \frac{# days supply including last event}{first event to observation window end}
$$

-   CMA3 is CMA1 capped at 1.0

-   CMA4 is CMA2 capped at 1.0

-   CMA7 is \# days theoretical use/observation window period, where gap days between dispenses are not included in time interval; so this allows for carryover and excludes the left over supply

-   CMA8 is \# days theoretical use/observation window *with lagged start*, where gap days are not included in time interval, and the lag is the days of carry over supply

-   CMA9 is (# observation window days weighted by ratio of days supply)/observation window. This means carry over and extra supply is evenly spread until next event. Using this with sliding window presents an issue because it assigns a CMA to periods when the patient should be NA/too long after their episode has ended. It is good at estimating a CMA during gaps though; it's not perfect but ultimately less than 80% which is what really matters.

Feb 19: After reading more into Vollmer et al. (2012), I am not convinced that MPR is what we want to plot. MPR seems to be better suited for longer intervals (e.g., if wanted 6-months or whole study period) rather than what we're trying to consider. Proportion of days covered may actually be of interest. Vollmer suggests MDC is more indicator of medication dispense/whether refills obtained, which is what we're interested in as well though. **Will need to** **discuss/defend choice.**

Summary of notes from before: Had a lot of back and forth about which CMAs to use and trouble with the OW duration varying between patients. With CMA 1-4, got a lot of 1 or NA, then CMA 5-9, got 0's after last dispense until OW end, which made it seem like artificial non-adherence. The CMAs 5-9 would correctly classify as NA before the first dispenses.

-   unresolved thought from before: may need to quantify the number missing and whether it's because they stopped treatment early vs. should have stopped. But that is a question of persistence, not adherence.

My current solution is to run Sliding Window CMA function for each patient to allow for variation in OW. Set the follow up (FU) start before the study period start of Jan 1, 2018 to allow for calculation of adherence for the month of January 2018 if they were completing a fill.

```{r}
#| echo: true
#| warning: false
#| label: function-creation

# function to run CMA
run_CMA <- function(data, cma_choice, FU_start, FU_duration){
  OW_duration <- min(208, first(data$OW_duration))
  Jan1 <- as.Date("2018-01-01", format = "%Y-%m-%d") 
  
  cma <- CMA_sliding_window(CMA.to.apply = cma_choice,
                     data = data,
                     ID.colname = "StudyID",
                     event.date.colname = "dispense_dt",
                     event.duration.colname = "days_supply",
                     event.daily.dose.colname ="daily_dose",
                     medication.class.colname = "AETdrug",
                     carry.only.for.same.medication = FALSE,
                     consider.dosage.change = FALSE,
                     followup.window.start = FU_start,
                     followup.window.duration = FU_duration,
                     followup.window.duration.unit = "weeks",
                     observation.window.start = Jan1,
                     observation.window.duration = OW_duration,
                     observation.window.duration.unit = "weeks",
                     sliding.window.start = 0, 
                     sliding.window.start.unit = "weeks",
                     sliding.window.duration = 4,
                     sliding.window.duration.unit = "weeks",
                     # if window and step are same, there is no overlap
                     sliding.window.step.duration = 4,
                     sliding.window.step.unit = "weeks",
                     date.format = "%Y/%m/%d",
                     parallel.backend = "none",
                     parallel.threads = 1) 
  result <- as_tibble(cma$CMA)
  return(result)
}
```

```{r}
#| echo: true
#| eval: false
#| warning: false
#| label: sandbox

# 1. set study period 
# technically, follow up starting 16 weeks before study period to allow for previous fill
FU_start <- as.Date("2017-10-09", format = "%Y-%m-%d") 
COVID_start <- as.Date("2020-03-11", format = "%Y-%m-%d")
FU_end <- as.Date("2022-01-01", format = "%Y-%m-%d")
FU_dur <- as.integer(difftime(FU_end, FU_start, units = "weeks"))
# 2. get each person's overall persistent episode and IDs
# TODO revisit start date to allow for the fills right before 1/1/18 
IDlist <- study_pop %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
   summarise(first_dispense = min(dispense_dt),
          last_dispense = max(dispense_dt),
          days_supply = last(days_supply)) %>%
  mutate(OW_end = last_dispense + days_supply + 30,
         OW_duration = as.integer(ceiling((difftime(OW_end, "2018-01-01", units = "weeks"))/4) * 4)) %>%
  select(StudyID, first_dispense, last_dispense, OW_end, OW_duration)
# TODO later keep more variables for subgroup analyses

study_run <- study_pop %>%
  inner_join(IDlist, by = "StudyID")

# run function for each participant
pdc_cma7 <- study_run %>%
  group_by(StudyID) %>%
  do(run_CMA(., "CMA7", FU_start, FU_dur)) 
pdc_cma7 <- as_tibble(pdc_cma7)
write_rds(pdc_cma7, "./data/pdc-cma7.rds")

pdc_cma5 <- study_run %>%
  group_by(StudyID) %>%
  do(run_CMA(., "CMA5", FU_start, FU_dur)) 
pdc_cma5 <- as_tibble(pdc_cma5)
write_rds(pdc_cma5, "./data/pdc-cma5.rds")

mpr_cma4 <- study_run %>%
  group_by(StudyID) %>%
  do(run_CMA(., "CMA4", FU_start, FU_dur)) 
mpr_cma4 <- as_tibble(mpr_cma4)
write_rds(mpr_cma4, "./data/mpr-cma4.rds")

######
# getting output for one set of results
# code was used to build function:
cma7 <- pdc_cma7 %>%
    mutate(adherent = case_when(
    CMA >= 0.80 ~ 1,
    CMA < 0.80 ~ 0)) %>%
  group_by(window.ID, window.start) %>%
  reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            prop_adherent = adherent_count/(adherent_count + non_adherent_count),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA) %>%
  mutate(post_COVID = if_else(window.start >= COVID_start, 1, 0))

cma7 %>% select(prop_adherent, window.ID) %>%
  tbl_summary(by = window.ID)

its_cma7 <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = cma7)
summary(its_cma7)

cma7$fit <- predict(its_cma7)

ggplot(cma7, aes(x = window.start, y = prop_adherent)) +
  geom_point() +
  geom_line(aes(y = fit), colour = "blue", linewidth = 1) +
  geom_vline(xintercept = COVID_start, colour = "red") +
  labs(title = "4-week PDC (CMA7)", x = "Year", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0,1), expand = c(0, 0)) 

tbl_regression(its_cma7)
```

Feb 13: Questions to ask Anke, Kevin, Tim about ITS thoughts. Specifically:

1.  Should we use this vs. splines? smoothing?
2.  Should the two points be constrained to be equal at time of intervention (in which case, would not be doing interrupted time series)

### Interrupted Time Series

I've seen two versions of interrupted time series formulas:

-   Option 1: Y \~ $\beta_{0}$time + $\beta_{1}$COVID + $\beta_{2}$time \* COVID

-   Option 2: Y \~ $\beta_{0}$time + $\beta_{1}$COVID + $\beta_{2}$time since COVID start

where:

-   $\beta_{1}$ = trend before COVID

-   $\beta_{2}$ = level of change right after start of COVID

-   $\beta_{3}$ = trend after COVID

```{r}
#| echo: true
#| warning: false
#| label: its

# function that outputs regression table and basic ggplot
# input dataset is the output of CMA results saved as tibble
get_cma_results <- function(dataset, COVID_start){
  table1 <- c()
  reg_plot <- c()
  reg_table <- c()
  results_list <- c()
  
  dataset <- dataset %>%
      mutate(adherent = case_when(
      CMA >= 0.80 ~ 1,
      CMA < 0.80 ~ 0)) %>%
    group_by(window.ID, window.start) %>%
    reframe(adherent_count = sum(adherent == 1, na.rm = TRUE), 
            non_adherent_count = sum(adherent == 0, na.rm = TRUE),
            adherent_NA_count = sum(is.na(adherent)),
            prop_adherent = adherent_count/(adherent_count + non_adherent_count),
            prop_NA = adherent_NA_count/(adherent_NA_count + adherent_count + adherent_NA_count),
          inverse_prop_NA = 1 - prop_NA) %>%
    mutate(post_COVID = if_else(window.start >= COVID_start, 1, 0))

  table1 <- dataset %>% select(prop_adherent, window.ID) %>%
    tbl_summary(by = window.ID)

  its <- lm(prop_adherent ~ window.ID + post_COVID + window.ID*post_COVID, data = dataset)
  reg_table <- tbl_regression(its)

  dataset$fit <- predict(its)

reg_plot <- ggplot(dataset, aes(x = window.start, y = prop_adherent)) +
  geom_point() +
  geom_line(aes(y = fit), colour = "blue", linewidth = 1) +
  geom_vline(xintercept = COVID_start, colour = "red") 
  
  results_list <- list(table_adherent = table1, 
                   reg_plot = reg_plot, 
                   reg_table = reg_table,
                   data_summary = dataset)
  
  return(results_list)
}

FU_start <- as.Date("2017-10-09", format = "%Y-%m-%d") 
COVID_start <- as.Date("2020-03-11", format = "%Y-%m-%d")
FU_end <- as.Date("2022-01-01", format = "%Y-%m-%d")
FU_dur <- as.integer(difftime(FU_end, FU_start, units = "weeks"))

# the cmas I'm reading in were created in sandbox chunk
# TODO eventually label tables and figures
cma7 <- read_rds("./data/pdc-cma7.rds")
cma7_results <- get_cma_results(cma7, COVID_start)
cma7_plot <- cma7_results$reg_plot + 
  labs(title = "4-week PDC (CMA7)", x = "Year", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0.5,1)) +
  theme_classic()

cma5 <- read_rds("./data/pdc-cma5.rds")
cma5_results <- get_cma_results(cma5, COVID_start)
cma5_plot <- cma5_results$reg_plot + 
  labs(title = "4-week PDC (CMA5)", x = "Year", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0.5,1)) +
  theme_classic()

cma4 <- read_rds("./data/mpr-cma4.rds")
cma4_results <- get_cma_results(cma4, COVID_start)
cma4_plot <- cma4_results$reg_plot + 
  labs(title = "4-week MPR (CMA4)", x = "Year", y = "Proportion Adherent (80%)") +
  scale_y_continuous(limits = c(0.5,1)) +
  theme_classic()

cma4_plot / cma5_plot / cma7_plot
```

Well.. these look pretty different. Comparing the regressions:
```{r}
#| echo: false
as_flex_table(cma4_results$reg_table %>% 
                modify_header(label ~ "**CMA4**"))
as_flex_table(cma5_results$reg_table %>%
                modify_header(label ~ "**CMA5**"))
as_flex_table(cma7_results$reg_table %>%
                modify_header(label ~ "**CMA7**"))
# TODO pull up some stats that may be help figure out the differences
# summarize adherence %s and missing %s
```
Overall, the betas are pretty much 0. Womp.

![Figure from Turner paper](./data/TurnerFigure1.png)

**References** 

Dima, A.L., Dediu, D., 2017. Computation of adherence to medication and visualization of medication histories in R with AdhereR: Towards transparent and reproducible use of electronic healthcare data. PLoS One 12, e0174426. https://doi.org/10.1371/journal.pone.0174426 

Turner, S.L., Karahalios, A., Forbes, A.B., Taljaard, M., Grimshaw, J.M., McKenzie, J.E., 2021. Comparison of six statistical methods for interrupted time series studies: empirical evaluation of 190 published series. BMC Medical Research Methodology 21, 134. https://doi.org/10.1186/s12874-021-01306-w

Vollmer, W.M., Xu, M., Feldstein, A., Smith, D., Waterbury, A., Rand, C., 2012. Comparison of pharmacy-based measures of medication adherence. BMC Health Serv Res 12, 155. https://doi.org/10.1186/1472-6963-12-155

#### Random other code and notes 

Code may not show up depending on chunk settings...

```{r}
#| echo: false
#| eval: false
#| label: old-testing-code

# Code used to compare the CMAs and test the CMA function.
# random sample to compare CMAs
# note that StudyID = 3 is excluded actually 
test_dataset <- studydata %>%
   filter(StudyID %in% c(3, 6, 9, 12, 10652, 32672, 38858, 9354, 40148)) %>%
   select(StudyID, dispense_dt, days_supply, drug_group, daily_dose, AETdrug) %>%
  group_by(StudyID) %>%
    arrange(dispense_dt, .by_group = TRUE) %>%
    mutate(dispense_end = as.Date(dispense_dt + days_supply),
         next_dispense = lead(dispense_dt, default = NULL),
         days_interval = as.integer(difftime(next_dispense, dispense_dt, units = "days")),
         MPR = days_supply/(days_interval),
         capped_MPR = pmin(MPR, 1, na.rm = FALSE)
         ) %>%
  ungroup() 

ID_test <- test_dataset %>%
  group_by(StudyID) %>%
  arrange(dispense_dt) %>%
   summarise(first_dispense = min(dispense_dt),
          last_dispense = max(dispense_dt),
          days_supply = last(days_supply)) %>%
  mutate(OW_end = last_dispense + days_supply + 90,
         OW_duration = as.integer(ceiling((difftime(OW_end, "2018-01-01", units = "weeks"))/4) * 4)) %>%
  select(StudyID, first_dispense, last_dispense, OW_end, OW_duration)

test2 <- test_dataset %>%
  inner_join(ID_test, by = "StudyID")

FU_start <- as.Date("2017-10-09", format = "%Y-%m-%d") 
FU_end <- as.Date("2022-01-01", format = "%Y-%m-%d")
FU_dur <- as.integer(difftime(FU_end, FU_start, units = "weeks"))

test_results <- test2 %>%
  group_by(StudyID) %>%
  do(run_CMA(., "CMA7", FU_start, FU_dur)) 

```

Started to try to calculate MPR myself... didn't get very far. If I were to would:

-   first for each patient, get MPR for each dispense date (and then set a min MPR, 1 - capped variable) then then later create dates dataset that seeks if there is an MPR in that week, to use it. THEN can add a check that if there was an MPR within 90 days it is 0, and if not it is NA. because those people are still in treatment episode.

    -   group by studyID and get +/- 1 event in dispenses

-   loop through each week, seek for dispense date within that week. - carry over based on days supply

```{r}
#| echo: false
#| eval: false
#| warning: false
#| label: DIY

whatever <- studypopdata %>%
   filter(StudyID %in% c(3, 6, 9, 12, 216, 1330, 6288, 18857, 22120)) %>%
   select(StudyID, dispense_dt, days_supply, drug_group, daily_dose, AETdrug) 

new_test <- whatever %>%
  arrange(StudyID, dispense_dt) %>%
  group_by(StudyID) %>%
# lead picks next date. Default is for last variable
# TODO revisit what the last variable should be if not null for last window. 
  mutate(dispense_end = as.Date(dispense_dt + days_supply),
         next_dispense = lead(dispense_dt, default = NULL),
         days_interval = as.integer(difftime(next_dispense, dispense_dt, units = "days")),
         MPR = days_supply/(days_interval),
         capped_MPR = pmin(MPR, 1, na.rm = FALSE)
         ) %>%
  ungroup()

months_df <- data.frame(date = seq(as.Date("2018-01-01"), as.Date("2021-12-01"), by = "month")) %>%
  mutate(month_year = format(date, "%Y-%m"))

new_attempt <- whatever %>%
  mutate(month_year = format(dispense_dt, "%Y-%m")) %>%
  full_join(months_df, by = "month_year") %>%
  mutate(MPR = if_else(between(day(dispense_dt), 1, 15) | between(day(dispense_end), 1, 15), capped_MPR, NA_real_)) 


```
